<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Minion Maze - Mobile Polish</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #score-board {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            color: #ffdb4d;
        }

        #lives-display {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            color: #ff4444;
        }

        #powerup-status {
            font-size: 24px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 10px #000;
            display: none;
        }

        #commentary-box {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #426bb3;
            border-radius: 15px;
            padding: 15px;
            color: #fff;
            text-align: center;
            font-size: 18px;
            font-style: italic;
            z-index: 10;
            display: none;
            box-shadow: 0 0 20px rgba(66, 107, 179, 0.5);
        }

        #commentary-title {
            font-size: 12px;
            text-transform: uppercase;
            color: #ffdb4d;
            margin-bottom: 5px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #commentary-text {
            min-height: 24px;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 20;
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            color: #ffdb4d;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 #426bb3;
        }

        p {
            font-size: 18px;
            color: #ddd;
            max-width: 500px;
            text-align: center;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            gap: 15px;
            font-size: 14px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: #ffdb4d;
            color: #333;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 219, 77, 0.4);
            transition: transform 0.1s, background 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            background: #ffe57f;
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* UPDATED JOYSTICK STYLES */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            z-index: 30;
            touch-action: none;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #ffdb4d, #d4a017);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            /* Let touches pass through to base */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), inset 0 2px 4px rgba(255, 255, 255, 0.4);
            transition: transform 0.1s;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }

            h1 {
                font-size: 32px;
            }

            #commentary-box {
                width: 90%;
                bottom: 200px;
                font-size: 14px;
            }
        }

        .typing::after {
            content: '...';
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0% {
                opacity: .2;
            }

            20% {
                opacity: 1;
            }

            100% {
                opacity: .2;
            }
        }
    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="ui-layer">
        <div id="score-board">SCORE: 0</div>
        <div id="lives-display">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="powerup-status"></div>
    </div>

    <div id="commentary-box">
        <div id="commentary-title">Gemini AI Commentary ‚ú®</div>
        <div id="commentary-text">Initializing...</div>
    </div>

    <div id="message-overlay">
        <h1>Minion Maze</h1>
        <p>Collect <b>BANANAS</b>. Avoid the ghosts.</p>
        <p>Use the <b>Purple Tunnels</b> to warp across the map!</p>
        <div class="legend">
            <span style="color:#ffff00">üçç Giant Mode</span>
            <span style="color:#ffaa00">ü•≠ Freeze</span>
            <span style="color:#ff4444">üçì Invincible</span>
            <span style="color:#ff0000">üçé +1 Life</span>
            <span style="color:#8b4513">üí© Slow</span>
        </div>
        <p style="color: #ffdb4d; font-size: 14px;">‚ú® Press <b>'C'</b>: Camera | <b>'M'</b>: New Maze | <b>'P'</b>:
            Switch Character ‚ú®</p>
        <p>Use <b>Arrow Keys</b> or <b>WASD</b> to move.</p>
        <button id="start-btn">PLAY</button>
    </div>

    <div id="mobile-controls">
        <div id="joystick-stick"></div>
    </div>
    <div id="game-container"></div>

    <script>
        /**
         * 3D MINION MAZE - Final Feature Set
         * Powered by Three.js & Gemini API
         */

        // --- AUDIO SYSTEM ---
        let audioCtx;
        const soundEnabled = true;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx || !soundEnabled) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'waka') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'coin') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.exponentialRampToValueAtTime(1800, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'powerup') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'splat') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.4);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'eatghost') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'warp') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        }

        // --- GEMINI API SETUP ---
        const apiKey = "";

        async function callGemini(prompt, systemInstruction = "") {
            if (!apiKey) return "AI Unavailable (No Key)";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }], systemInstruction: { parts: [{ text: systemInstruction }] } };
            try {
                const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "...";
            } catch (error) {
                console.error("Gemini API Error:", error);
                return "Thinking failed...";
            }
        }

        // --- UI HELPERS ---
        const commBox = document.getElementById('commentary-box');
        const commText = document.getElementById('commentary-text');
        const commTitle = document.getElementById('commentary-title');

        function showCommentary(text, title = "Gemini AI Commentary ‚ú®") {
            commBox.style.display = 'block';
            commTitle.innerText = title;
            commText.innerText = text;
            if (gameState === 'PLAYING') {
                clearTimeout(window.commTimeout);
                window.commTimeout = setTimeout(() => { commBox.style.display = 'none'; }, 5000);
            }
        }

        function showLoadingCommentary(title) {
            commBox.style.display = 'block';
            commTitle.innerText = title;
            commText.innerHTML = '<span class="typing">AI Thinking</span>';
            clearTimeout(window.commTimeout);
        }

        function updateLivesUI() {
            const hearts = "‚ù§Ô∏è".repeat(lives);
            document.getElementById('lives-display').innerText = `Lives: ${hearts}`;
        }

        // --- GAME CONFIGURATION ---
        const TILE_SIZE = 10;
        const SPEED = 0.06;
        const GHOST_SPEED = 0.04;
        const CHASE_RADIUS_TILES = 8;
        const COLOR_GROUND = 0x111111;
        const COLOR_BANANA = 0xffea00;

        const FRUIT_BANANA = 0;
        const FRUIT_PINEAPPLE = 2;
        const FRUIT_MANGO = 3;
        const FRUIT_STRAWBERRY = 4;
        const FRUIT_APPLE = 5; // New: Extra Life
        const FRUIT_POOP = 6; // New: Poop

        // Default Map (Classic)
        const MAP_DEFAULT = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 0, 1, 1, 1, 9, 1, 9, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 9, 9, 9, 9, 9, 9, 9, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 1, 9, 1, 1, 9, 1, 1, 9, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 0, 1, 9, 1, 9, 9, 9, 1, 9, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 9, 1, 1, 1, 1, 1, 9, 1, 0, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], // Warp Row (Index 11)
            [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // Procedural Map Settings
        const MAP_WIDTH_CELLS = 21;
        const MAP_HEIGHT_CELLS = 21;
        let MAP_LAYOUT = [];
        let WARP_ROW_INDEX = 11; // Default for classic map

        // --- PROCEDURAL GENERATION ---
        function generateMaze(width, height) {
            let map = Array(height).fill().map(() => Array(width).fill(1));

            function carve(x, y) {
                map[y][x] = 0;
                const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);

                for (let [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && map[ny][nx] === 1) {
                        map[y + dy / 2][x + dx / 2] = 0;
                        carve(nx, ny);
                    }
                }
            }

            carve(1, 1);

            // Ghost House
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);
            for (let y = centerY - 1; y <= centerY + 1; y++) {
                for (let x = centerX - 2; x <= centerX + 2; x++) {
                    map[y][x] = 9;
                }
            }
            map[centerY - 2][centerX] = 0;

            // Warp Tunnels
            const warpRow = centerY;
            map[warpRow][0] = 0; map[warpRow][1] = 0; map[warpRow][2] = 0;
            map[warpRow][width - 1] = 0; map[warpRow][width - 2] = 0; map[warpRow][width - 3] = 0;

            // Imperfections (Loops)
            const extraHoles = Math.floor((width * height) * 0.05);
            for (let i = 0; i < extraHoles; i++) {
                const rx = Math.floor(Math.random() * (width - 2)) + 1;
                const ry = Math.floor(Math.random() * (height - 2)) + 1;
                if (map[ry][rx] === 1) map[ry][rx] = 0;
            }

            map[1][1] = 0; // Ensure start is clear
            return map;
        }

        // --- GLOBALS ---
        let scene, camera, renderer;
        let player, ghosts = [];
        let items = [];
        let gameState = 'START';
        let score = 0;
        let lives = 3;
        let mapWidth, mapHeight;
        let lastAiTriggerTime = 0;
        let wakaTimer = 0;
        let playerSpeedMultiplier = 1.0;

        let activePowerUp = null;
        let powerUpEndTime = 0;
        let isRespawnInvincible = false;
        let respawnEndTime = 0;

        let cameraMode = 'TACTICAL';
        let characterMode = 'MINION'; // 'MINION' or 'PACMAN'

        let currentDir = { x: 0, z: 0 };
        let nextDir = { x: 0, z: 0 };
        let isMoving = false;

        // --- INITIALIZATION ---
        function init() {
            const container = document.getElementById('game-container');

            // Setup Scene logic
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a1a1a, 0.005);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Initial Load (Default Map)
            loadLevel('DEFAULT');

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.getElementById('start-btn').addEventListener('click', startGame);

            setupTouchControls();
            animate();
        }

        function loadLevel(mode) {
            // 1. Determine Map
            if (mode === 'PROCEDURAL') {
                MAP_LAYOUT = generateMaze(MAP_WIDTH_CELLS, MAP_HEIGHT_CELLS);
                WARP_ROW_INDEX = Math.floor(MAP_HEIGHT_CELLS / 2);
            } else {
                // Clone default to avoid modifying the const
                MAP_LAYOUT = MAP_DEFAULT.map(row => [...row]);
                WARP_ROW_INDEX = 11;
            }

            mapHeight = MAP_LAYOUT.length;
            mapWidth = MAP_LAYOUT[0].length;

            // 2. Clear Scene
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            // 3. Re-add Essentials
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const light1 = new THREE.PointLight(0x426bb3, 2, 100);
            light1.position.set(20, 20, 20);
            scene.add(light1);

            const light2 = new THREE.PointLight(0xffdb4d, 2, 100);
            light2.position.set(mapWidth * TILE_SIZE - 20, 20, mapHeight * TILE_SIZE - 20);
            scene.add(light2);

            // 4. Reset Arrays
            ghosts = [];
            items = [];

            // 5. Build
            buildLevel();

            // 6. Reset Game State if reloading during play
            if (gameState !== 'START') {
                startGame();
            }

            // Reset Camera
            camera.position.set(mapWidth * TILE_SIZE / 2, 150, mapHeight * TILE_SIZE / 2 + 50);
            camera.lookAt(mapWidth * TILE_SIZE / 2, 0, mapHeight * TILE_SIZE / 2);

            showCommentary(mode === 'PROCEDURAL' ? "Generated New Maze!" : "Loaded Classic Maze", "SYSTEM");
        }

        function buildLevel() {
            const planeGeo = new THREE.PlaneGeometry(mapWidth * TILE_SIZE, mapHeight * TILE_SIZE);
            const planeMat = new THREE.MeshPhongMaterial({ color: COLOR_GROUND });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set((mapWidth * TILE_SIZE) / 2 - TILE_SIZE / 2, -0.1, (mapHeight * TILE_SIZE) / 2 - TILE_SIZE / 2);
            ground.receiveShadow = true;
            scene.add(ground);

            const wallGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x3344cc, roughness: 0.2, metalness: 0.5, emissive: 0x222255, emissiveIntensity: 0.3
            });

            // Warp Tunnel Indicators
            const warpGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const warpMat = new THREE.MeshBasicMaterial({ color: 0x9900ff, opacity: 0.5, transparent: true });

            const warpL = new THREE.Mesh(warpGeo, warpMat);
            warpL.rotation.x = -Math.PI / 2;
            warpL.position.set(0, 0.1, WARP_ROW_INDEX * TILE_SIZE);
            scene.add(warpL);

            const warpR = new THREE.Mesh(warpGeo, warpMat);
            warpR.rotation.x = -Math.PI / 2;
            warpR.position.set((mapWidth - 1) * TILE_SIZE, 0.1, WARP_ROW_INDEX * TILE_SIZE);
            scene.add(warpR);

            const validSpots = [];
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (MAP_LAYOUT[z][x] === 0 && !(x === 1 && z === 1)) {
                        validSpots.push({ x, z });
                    }
                }
            }

            validSpots.sort(() => Math.random() - 0.5);

            const spotTypeMap = {};
            if (validSpots.length > 5) {
                spotTypeMap[`${validSpots[0].x},${validSpots[0].z}`] = FRUIT_PINEAPPLE;
                spotTypeMap[`${validSpots[1].x},${validSpots[1].z}`] = FRUIT_MANGO;
                spotTypeMap[`${validSpots[2].x},${validSpots[2].z}`] = FRUIT_STRAWBERRY;
                spotTypeMap[`${validSpots[3].x},${validSpots[3].z}`] = FRUIT_APPLE;
                spotTypeMap[`${validSpots[4].x},${validSpots[4].z}`] = FRUIT_POOP;
            }

            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    const type = MAP_LAYOUT[z][x];
                    const posX = x * TILE_SIZE;
                    const posZ = z * TILE_SIZE;

                    if (type === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set(posX, TILE_SIZE / 2, posZ);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        const edges = new THREE.EdgesGeometry(wallGeo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x6677ff }));
                        wall.add(line);
                        scene.add(wall);
                    } else if (type === 0 && !(x === 1 && z === 1)) {
                        const key = `${x},${z}`;
                        const itemType = spotTypeMap[key] !== undefined ? spotTypeMap[key] : FRUIT_BANANA;
                        createItem(itemType, posX, posZ, x, z);
                    }
                }
            }

            createPlayer();
            createGhosts();
        }

        function createItem(type, posX, posZ, gridX, gridZ) {
            let mesh;

            if (type === FRUIT_BANANA) {
                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(-1.8, 1.2, 0),
                    new THREE.Vector3(0, -0.75, 0),
                    new THREE.Vector3(1.8, 1.2, 0)
                );
                const geo = new THREE.TubeGeometry(curve, 8, 0.6, 6, false);
                const mat = new THREE.MeshStandardMaterial({ color: COLOR_BANANA, roughness: 0.3, emissive: 0xaa8800, emissiveIntensity: 0.2 });
                mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = Math.PI / 6;
                mesh.rotation.z = Math.PI / 4;
            } else if (type === FRUIT_PINEAPPLE) {
                mesh = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 3, 8), new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaa6600, roughness: 0.8 }));
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1.5, 5), new THREE.MeshStandardMaterial({ color: 0x00aa00 }));
                leaves.position.y = 2;
                mesh.add(body); mesh.add(leaves);
            } else if (type === FRUIT_MANGO) {
                const geo = new THREE.SphereGeometry(1.8, 12, 12);
                geo.scale(1, 1.2, 0.8);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff4400, roughness: 0.2 });
                mesh = new THREE.Mesh(geo, mat);
            } else if (type === FRUIT_STRAWBERRY) {
                mesh = new THREE.Group();
                const body = new THREE.Mesh(new THREE.ConeGeometry(1.5, 2.5, 8), new THREE.MeshStandardMaterial({ color: 0xff2222, emissive: 0x550000 }));
                body.rotation.x = Math.PI; // Point down
                const top = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 0, 0.5, 6), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
                top.position.y = 1.2;
                mesh.add(body); mesh.add(top);
            } else if (type === FRUIT_APPLE) {
                mesh = new THREE.Group();
                const body = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.2 }));
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1, 8), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
                stem.position.y = 1.4;
                mesh.add(body); mesh.add(stem);
            } else if (type === FRUIT_POOP) {
                mesh = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
                const base = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), mat);
                base.scale.set(1, 0.5, 1);
                const mid = new THREE.Mesh(new THREE.SphereGeometry(1.0, 8, 8), mat);
                mid.position.y = 0.8;
                mid.scale.set(1, 0.5, 1);
                const top = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), mat);
                top.position.y = 1.4;
                mesh.add(base); mesh.add(mid); mesh.add(top);
            }

            // SCALING & POSITIONING
            if (type !== FRUIT_BANANA) {
                mesh.scale.set(2, 2, 2); // Make powerups BIG
                mesh.position.set(posX, 4, posZ); // Float higher
            } else {
                mesh.scale.set(2, 2, 2); // Make bananas BIGGER too! (Originally was default, now 2x)
                mesh.position.set(posX, 2, posZ);
            }

            scene.add(mesh);
            items.push({ mesh: mesh, active: true, x: gridX, z: gridZ, type: type });
        }

        function updateCharacterMesh() {
            // clear children
            while (player.children.length > 0) {
                player.remove(player.children[0]);
            }

            if (characterMode === 'MINION') {
                const yellow = new THREE.MeshStandardMaterial({ color: 0xffdb4d, transparent: true, opacity: 1 });
                const blue = new THREE.MeshStandardMaterial({ color: 0x426bb3, transparent: true, opacity: 1 });
                const black = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 1 });
                const white = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });

                const body = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), yellow);
                body.position.y = 3;
                player.add(body);

                const head = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), yellow);
                head.position.y = 6;
                player.add(head);

                const pants = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), blue);
                pants.rotation.x = Math.PI;
                player.add(pants);

                const band = new THREE.Mesh(new THREE.CylinderGeometry(2.55, 2.55, 0.8, 16), black);
                band.position.y = 5.5;
                player.add(band);

                const eye = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16), white);
                eye.position.set(0, 5.5, 1.8);
                player.add(eye);

                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ color: 0x553311 }));
                pupil.position.set(0, 5.5, 2.8);
                player.add(pupil);
            } else {
                // PACMAN
                const pacmanGeo = new THREE.SphereGeometry(3.5, 32, 32, 0.2 * Math.PI, 1.6 * Math.PI);
                const pacmanMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                const pacman = new THREE.Mesh(pacmanGeo, pacmanMat);

                // Orient mouth
                pacman.rotation.x = -Math.PI / 2;
                pacman.rotation.z = Math.PI / 2;
                pacman.position.y = 3.5;

                player.add(pacman);
            }
        }

        function createPlayer() {
            player = new THREE.Group();
            updateCharacterMesh(); // Build initial mesh
            player.position.set(TILE_SIZE * 1, 0, TILE_SIZE * 1);
            player.castShadow = true;
            scene.add(player);
        }

        function toggleCharacter() {
            characterMode = characterMode === 'MINION' ? 'PACMAN' : 'MINION';
            updateCharacterMesh();
            showCommentary(`Switched to ${characterMode}!`, "SYSTEM");
        }

        function createGhosts() {
            const colors = [0xff0000, 0xffb8ff, 0x00ffff, 0xffb852];
            const names = ["Blinky", "Pinky", "Inky", "Clyde"];

            colors.forEach((col, i) => {
                const gGroup = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({
                    color: col,
                    roughness: 0.2,
                    emissive: col,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.3
                });

                spawnEntity(gGroup, 9, i);

                gGroup.userData = {
                    id: i,
                    name: names[i],
                    currentDir: { x: 0, z: 0 },
                    targetPos: gGroup.position.clone(),
                    speed: GHOST_SPEED,
                    activationTime: 0,
                    chaseMode: false,
                    scared: false,
                    material: mat,
                    originalColor: col
                };

                const top = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), mat);
                top.position.y = 3;
                gGroup.add(top);
                const skirt = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 3, 16), mat);
                skirt.position.y = 1.5;
                gGroup.add(skirt);

                const eyeW = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const eyeB = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const le = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), eyeW); le.position.set(-1, 3.5, 1.8); gGroup.add(le);
                const re = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), eyeW); re.position.set(1, 3.5, 1.8); gGroup.add(re);
                const lp = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), eyeB); lp.position.set(-1, 3.5, 2.4); gGroup.add(lp);
                const rp = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), eyeB); rp.position.set(1, 3.5, 2.4); gGroup.add(rp);

                ghosts.push(gGroup);
                scene.add(gGroup);
            });
        }

        function spawnEntity(obj, typeCode, offset = 0) {
            let spots = [];
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (MAP_LAYOUT[z][x] === typeCode) spots.push({ x, z });
                }
            }
            if (spots.length === 0) spots.push({ x: 1, z: 1 });

            const spot = spots[offset % spots.length];
            obj.position.set(spot.x * TILE_SIZE, 0, spot.z * TILE_SIZE);
        }

        function getGridPos(pos) {
            return { x: Math.round(pos.x / TILE_SIZE), z: Math.round(pos.z / TILE_SIZE) };
        }

        function isWalkable(gx, gz) {
            if (gz === WARP_ROW_INDEX && (gx < 0 || gx >= mapWidth)) return true;
            if (gx < 0 || gx >= mapWidth || gz < 0 || gz >= mapHeight) return false;
            return MAP_LAYOUT[gz][gx] !== 1;
        }

        function checkWarp(entity) {
            if (Math.abs(entity.position.z - WARP_ROW_INDEX * TILE_SIZE) < 5) {
                if (entity.position.x < -5) {
                    entity.position.x = (mapWidth * TILE_SIZE) - 5;
                    if (entity === player) playSound('warp');
                } else if (entity.position.x > (mapWidth * TILE_SIZE) + 5) {
                    entity.position.x = 5;
                    if (entity === player) playSound('warp');
                }
            }
        }

        // --- LOGIC ---

        function activatePowerUp(type) {
            const statusDiv = document.getElementById('powerup-status');
            statusDiv.style.display = 'block';

            activePowerUp = type;
            const now = Date.now();

            if (type === FRUIT_PINEAPPLE) {
                powerUpEndTime = now + 30000;
                statusDiv.innerText = "üçç GIANT MODE (30s)";
                statusDiv.style.color = "#ffff00";
                player.scale.set(1.6, 1.6, 1.6);
                playSound('powerup');
                showCommentary("I AM GIANT! RUN GHOSTS!", "PINEAPPLE POWER");
            }
            else if (type === FRUIT_MANGO) {
                powerUpEndTime = now + 10000;
                statusDiv.innerText = "ü•≠ FREEZE (10s)";
                statusDiv.style.color = "#ffaa00";
                playSound('powerup');
                showCommentary("Ghosts Frozen!", "MANGO POWER");
            }
            else if (type === FRUIT_STRAWBERRY) {
                powerUpEndTime = now + 15000;
                statusDiv.innerText = "üçì INVINCIBLE (15s)";
                statusDiv.style.color = "#ff4444";
                playSound('powerup');
                showCommentary("Can't Touch This!", "STRAWBERRY POWER");
            }
            else if (type === FRUIT_POOP) {
                powerUpEndTime = now + 10000;
                statusDiv.innerText = "üí© POOP (10s)";
                statusDiv.style.color = "#8b4513";
                playSound('splat');
                playerSpeedMultiplier = 0.75;
                showCommentary("Eww! You stepped in it! Slowed down.", "POOP");
            }
        }

        function updatePowerUps() {
            if (!activePowerUp) return;

            if (Date.now() > powerUpEndTime) {
                activePowerUp = null;
                document.getElementById('powerup-status').style.display = 'none';

                player.scale.set(1, 1, 1);
                playerSpeedMultiplier = 1.0;

                ghosts.forEach(g => {
                    if (g.userData.material) {
                        g.userData.material.color.setHex(g.userData.originalColor);
                        g.userData.material.emissive.setHex(g.userData.originalColor);
                    }
                });

                showCommentary("Power-up Expired.", "System");
            }
        }

        function handlePlayerHit() {
            if (isRespawnInvincible || activePowerUp === FRUIT_STRAWBERRY) return;

            playSound('splat');
            lives--;
            updateLivesUI();

            if (lives <= 0) {
                gameOver();
            } else {
                respawnPlayer();
            }
        }

        function respawnPlayer() {
            player.position.set(1 * TILE_SIZE, 0, 1 * TILE_SIZE);

            currentDir = { x: 0, z: 0 };
            nextDir = { x: 0, z: 0 };

            isRespawnInvincible = true;
            respawnEndTime = Date.now() + 5000;

            player.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 0.3;
                }
            });

            showCommentary("Respawned at Start! Invisible for 5s.", "SYSTEM");
        }

        function updatePlayer() {
            const pPos = player.position;
            const gridPos = getGridPos(pPos);

            if (isRespawnInvincible && Date.now() > respawnEndTime) {
                isRespawnInvincible = false;
                player.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = 1.0;
                    }
                });
                showCommentary("You are solid again!", "WARNING");
            }

            const worldX = gridPos.x * TILE_SIZE;
            const worldZ = gridPos.z * TILE_SIZE;

            const moveStep = SPEED * playerSpeedMultiplier * TILE_SIZE;
            const dist = Math.sqrt(Math.pow(pPos.x - worldX, 2) + Math.pow(pPos.z - worldZ, 2));

            if (dist <= moveStep) {
                if (nextDir.x !== 0 || nextDir.z !== 0) {
                    if (isWalkable(gridPos.x + nextDir.x, gridPos.z + nextDir.z)) {
                        currentDir = { ...nextDir };
                        player.position.x = worldX;
                        player.position.z = worldZ;
                        nextDir = { x: 0, z: 0 };
                    }
                }
                if (!isWalkable(gridPos.x + currentDir.x, gridPos.z + currentDir.z)) {
                    currentDir = { x: 0, z: 0 };
                    player.position.x = worldX;
                    player.position.z = worldZ;
                    isMoving = false;
                } else {
                    isMoving = true;
                }
            }

            player.position.x += currentDir.x * moveStep;
            player.position.z += currentDir.z * moveStep;

            checkWarp(player);

            if (currentDir.x === 1) player.rotation.y = Math.PI / 2;
            else if (currentDir.x === -1) player.rotation.y = -Math.PI / 2;
            else if (currentDir.z === 1) player.rotation.y = 0;
            else if (currentDir.z === -1) player.rotation.y = Math.PI;

            if (isMoving) {
                player.position.y = Math.abs(Math.sin(Date.now() * 0.01));
                wakaTimer += 16;
                if (wakaTimer > 250) {
                    playSound('waka');
                    wakaTimer = 0;
                }
            }

            items.forEach(item => {
                if (item.active) {
                    item.mesh.rotation.y += 0.03;

                    const pickupDist = activePowerUp === FRUIT_PINEAPPLE ? 25 : 15;
                    const dx = player.position.x - item.mesh.position.x;
                    const dz = player.position.z - item.mesh.position.z;

                    if ((dx * dx + dz * dz) < pickupDist) {
                        item.active = false;
                        item.mesh.visible = false;

                        if (item.type === FRUIT_BANANA) {
                            score += 10;
                            playSound('coin');
                        } else if (item.type === FRUIT_APPLE) {
                            score += 50;
                            lives++;
                            updateLivesUI();
                            playSound('powerup');
                            showCommentary("Extra Life! ‚ù§Ô∏è", "APPLE");
                        } else {
                            score += 50;
                            activatePowerUp(item.type);
                        }

                        document.getElementById('score-board').innerText = "SCORE: " + score;
                        checkWin();
                    }
                }
            });
        }

        function updateGhosts() {
            const CHASE_DIST_SQ = (TILE_SIZE * CHASE_RADIUS_TILES) ** 2;

            ghosts.forEach(ghost => {
                if (activePowerUp === FRUIT_MANGO) {
                    ghost.children[0].position.y = 3;
                    return;
                }

                if (Date.now() < ghost.userData.activationTime) {
                    ghost.children[0].position.y = 3 + Math.sin(Date.now() * 0.005 + ghost.userData.id) * 0.5;
                    ghost.children.forEach(c => { if (c.material && c.material.transparent) c.material.opacity = 0.3; });
                    return;
                }

                ghost.children.forEach(c => { if (c.material && c.material.transparent) c.material.opacity = 0.9; });

                if (ghost.userData.material) {
                    if (activePowerUp === FRUIT_PINEAPPLE) {
                        ghost.userData.material.color.setHex(0x0000ff);
                        ghost.userData.material.emissive.setHex(0x0000aa);
                    } else {
                        ghost.userData.material.color.setHex(ghost.userData.originalColor);
                        ghost.userData.material.emissive.setHex(ghost.userData.originalColor);
                    }
                }

                const step = ghost.userData.speed * TILE_SIZE;
                const currentPos = ghost.position;
                const targetPos = ghost.userData.targetPos;

                const dx = targetPos.x - currentPos.x;
                const dz = targetPos.z - currentPos.z;
                const distToTarget = Math.sqrt(dx * dx + dz * dz);

                if (distToTarget < step) {
                    ghost.position.copy(targetPos);

                    const gridPos = getGridPos(ghost.position);
                    const dirs = [{ x: 0, z: -1 }, { x: 0, z: 1 }, { x: -1, z: 0 }, { x: 1, z: 0 }];
                    const validMoves = [];

                    dirs.forEach(d => {
                        if (isWalkable(gridPos.x + d.x, gridPos.z + d.z)) validMoves.push(d);
                    });

                    if (validMoves.length > 0) {
                        const currentDir = ghost.userData.currentDir;
                        let candidates = validMoves.filter(d => !(d.x === -currentDir.x && d.z === -currentDir.z));
                        if (candidates.length === 0) candidates = validMoves;

                        let chosenDir;
                        const distToPlayerSq = ghost.position.distanceToSquared(player.position);
                        const isChasing = distToPlayerSq < CHASE_DIST_SQ;

                        if (activePowerUp === FRUIT_PINEAPPLE) {
                            candidates.sort((a, b) => {
                                const posA = { x: (gridPos.x + a.x) * TILE_SIZE, z: (gridPos.z + a.z) * TILE_SIZE };
                                const posB = { x: (gridPos.x + b.x) * TILE_SIZE, z: (gridPos.z + b.z) * TILE_SIZE };
                                return ((posB.x - player.position.x) ** 2 + (posB.z - player.position.z) ** 2) -
                                    ((posA.x - player.position.x) ** 2 + (posA.z - player.position.z) ** 2);
                            });
                            chosenDir = candidates[0];
                        }
                        else if (isChasing && !isRespawnInvincible) {
                            if (!ghost.userData.chaseMode) {
                                ghost.userData.chaseMode = true;
                                if (Date.now() - lastAiTriggerTime > 8000) {
                                    lastAiTriggerTime = Date.now();
                                    triggerGhostTaunt(ghost.userData.name);
                                }
                            }
                            candidates.sort((a, b) => {
                                const posA = { x: (gridPos.x + a.x) * TILE_SIZE, z: (gridPos.z + a.z) * TILE_SIZE };
                                const posB = { x: (gridPos.x + b.x) * TILE_SIZE, z: (gridPos.z + b.z) * TILE_SIZE };
                                return ((posA.x - player.position.x) ** 2 + (posA.z - player.position.z) ** 2) -
                                    ((posB.x - player.position.x) ** 2 + (posB.z - player.position.z) ** 2);
                            });
                            chosenDir = candidates[0];
                        }
                        else {
                            ghost.userData.chaseMode = false;
                            chosenDir = candidates[Math.floor(Math.random() * candidates.length)];
                        }

                        ghost.userData.currentDir = chosenDir;
                        ghost.userData.targetPos.set(
                            (gridPos.x + chosenDir.x) * TILE_SIZE,
                            0,
                            (gridPos.z + chosenDir.z) * TILE_SIZE
                        );
                    }
                } else {
                    const vx = dx / distToTarget;
                    const vz = dz / distToTarget;
                    ghost.position.x += vx * step;
                    ghost.position.z += vz * step;
                }

                checkWarp(ghost);

                ghost.children[0].position.y = 3 + Math.sin(Date.now() * 0.005 + ghost.userData.id) * 0.5;

                const pdx = player.position.x - ghost.position.x;
                const pdz = player.position.z - ghost.position.z;
                const touchDist = activePowerUp === FRUIT_PINEAPPLE ? TILE_SIZE * 1.5 : TILE_SIZE * 0.8;

                if (Math.sqrt(pdx * pdx + pdz * pdz) < touchDist) {
                    if (activePowerUp === FRUIT_PINEAPPLE) {
                        score += 200;
                        document.getElementById('score-board').innerText = "SCORE: " + score;
                        spawnEntity(ghost, 9);
                        ghost.userData.targetPos.copy(ghost.position);
                        ghost.userData.activationTime = Date.now() + 5000;
                        playSound('eatghost');
                        showCommentary(`Ate ${ghost.userData.name}!`, "CRUNCH!");
                    }
                    else {
                        handlePlayerHit();
                    }
                }
            });
        }

        function toggleCamera() {
            if (cameraMode === 'TACTICAL') {
                cameraMode = 'IMMERSIVE';
                showCommentary("Immersive Mode Active. Controls Relative.", "CAMERA");
            } else {
                cameraMode = 'TACTICAL';
                showCommentary("Tactical Mode Active. Controls Absolute.", "CAMERA");
            }
        }

        function updateCamera() {
            if (!player) return;

            if (cameraMode === 'TACTICAL') {
                const targetPos = new THREE.Vector3(mapWidth * TILE_SIZE / 2, 150, mapHeight * TILE_SIZE / 2 + 50);
                const lookAtPos = new THREE.Vector3(mapWidth * TILE_SIZE / 2, 0, mapHeight * TILE_SIZE / 2);
                camera.position.lerp(targetPos, 0.05);
                camera.lookAt(lookAtPos);
            } else {
                // IMMERSIVE: Behind player
                // Player faces +Z at rotation 0. Behind is -Z (and slightly up).
                const offset = new THREE.Vector3(0, 30, -30);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                const targetPos = player.position.clone().add(offset);

                camera.position.lerp(targetPos, 0.1);

                // Look slightly ahead
                const forward = new THREE.Vector3(0, 0, 10).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                const lookTarget = player.position.clone().add(forward);
                camera.lookAt(lookTarget);
            }
        }

        // --- AI FUNCTIONS ---

        async function triggerGhostTaunt(ghostName) {
            showLoadingCommentary(`${ghostName} is Chasing!`);
            const prompt = `You are ${ghostName}, a ghost in a Pacman maze game. You just started chasing the Minion player. Give a very short, funny, threatening taunt (max 8 words).`;
            const response = await callGemini(prompt, "You are a video game character.");
            showCommentary(response, `${ghostName} says:`);
        }

        async function triggerGameReview(isWin, finalScore) {
            showLoadingCommentary("Generating Performance Review...");
            const outcome = isWin ? "won" : "died to a ghost";
            const prompt = `You are a sarcastic Minion Manager. A minion just ${outcome} in the maze with a score of ${finalScore}. Give a short, sarcastic performance review (1 sentence).`;
            const response = await callGemini(prompt, "You are a sarcastic boss.");

            const overlay = document.getElementById('message-overlay');
            const p = overlay.querySelector('p');
            p.innerHTML = `Score: ${finalScore}<br><br><span style="color:#ffdb4d">" ${response} "</span>`;
            showCommentary(response, "Manager Review");
        }

        function animate() {
            requestAnimationFrame(animate);
            if (gameState === 'PLAYING') {
                updatePlayer();
                updateGhosts();
                updatePowerUps();
            }
            updateCamera();
            renderer.render(scene, camera);
        }

        function onKeyDown(e) {
            if (gameState !== 'PLAYING') return;

            if (e.key === 'c' || e.key === 'C') {
                toggleCamera();
                return;
            }

            // NEW: Procedural Maze Trigger
            if (e.key === 'm' || e.key === 'M') {
                loadLevel('PROCEDURAL');
                return;
            }

            if (e.key === 'p' || e.key === 'P') {
                toggleCharacter();
                return;
            }

            if (cameraMode === 'TACTICAL') {
                // Absolute Controls
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W': nextDir = { x: 0, z: -1 }; break;
                    case 'ArrowDown': case 's': case 'S': nextDir = { x: 0, z: 1 }; break;
                    case 'ArrowLeft': case 'a': case 'A': nextDir = { x: -1, z: 0 }; break;
                    case 'ArrowRight': case 'd': case 'D': nextDir = { x: 1, z: 0 }; break;
                }
            } else {
                // IMMERSIVE: Relative Controls
                // 0 = +Z (South), PI = -Z (North), PI/2 = +X (East), -PI/2 = -X (West)

                let forward = { x: 0, z: 0 };
                const rot = player.rotation.y;

                // Approximate facing based on rotation
                if (Math.abs(rot) < 0.1) forward = { x: 0, z: 1 }; // South
                else if (Math.abs(rot - Math.PI) < 0.1 || Math.abs(rot + Math.PI) < 0.1) forward = { x: 0, z: -1 }; // North
                else if (Math.abs(rot - Math.PI / 2) < 0.1) forward = { x: 1, z: 0 }; // East
                else if (Math.abs(rot + Math.PI / 2) < 0.1) forward = { x: -1, z: 0 }; // West
                else forward = { x: 0, z: 1 }; // Default

                const left = { x: forward.z, z: -forward.x };
                const right = { x: -forward.z, z: forward.x };
                const back = { x: -forward.x, z: -forward.z };

                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W': nextDir = forward; break;
                    case 'ArrowDown': case 's': case 'S': nextDir = back; break;
                    case 'ArrowLeft': case 'a': case 'A': nextDir = left; break;
                    case 'ArrowRight': case 'd': case 'D': nextDir = right; break;
                }
            }
        }

        function setupTouchControls() {
            const pad = document.getElementById('mobile-controls');
            let startX, startY;
            pad.addEventListener('touchstart', (e) => { e.preventDefault(); startX = e.touches[0].clientX; startY = e.touches[0].clientY; }, { passive: false });
            pad.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!startX || !startY) return;
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;
                if (Math.abs(dx) > Math.abs(dy)) { if (Math.abs(dx) > 10) nextDir = dx > 0 ? { x: 1, z: 0 } : { x: -1, z: 0 }; }
                else { if (Math.abs(dy) > 10) nextDir = dy > 0 ? { x: 0, z: 1 } : { x: 0, z: -1 }; }
            }, { passive: false });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            initAudio();
            gameState = 'PLAYING';
            document.getElementById('message-overlay').classList.add('hidden');
            document.getElementById('commentary-box').style.display = 'none';
            score = 0;
            lives = 3;
            activePowerUp = null;
            isRespawnInvincible = false;

            document.getElementById('score-board').innerText = "SCORE: 0";
            document.getElementById('powerup-status').style.display = 'none';
            updateLivesUI();

            player.position.set(1 * TILE_SIZE, 0, 1 * TILE_SIZE);
            player.scale.set(1, 1, 1);
            playerSpeedMultiplier = 1.0;

            player.traverse((child) => { if (child.isMesh && child.material) child.material.opacity = 1; });

            currentDir = { x: 0, z: 0 }; nextDir = { x: 0, z: 0 };

            const now = Date.now();
            ghosts.forEach((g, i) => {
                spawnEntity(g, 9, i);
                g.userData.currentDir = { x: 0, z: 0 };
                g.userData.targetPos.copy(g.position);
                g.userData.chaseMode = false;
                g.userData.activationTime = now + (i * 3000);

                if (g.userData.material) {
                    g.userData.material.color.setHex(g.userData.originalColor);
                    g.userData.material.emissive.setHex(g.userData.originalColor);
                }
            });

            items.forEach(p => { p.active = true; p.mesh.visible = true; });
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            const ov = document.getElementById('message-overlay');
            ov.classList.remove('hidden');
            ov.querySelector('h1').innerText = "GAME OVER";
            ov.querySelector('p').innerHTML = `Score: ${score}<br>Analyzing performance...`;
            ov.querySelector('button').innerText = "RESTART";

            triggerGameReview(false, score);
        }

        function checkWin() {
            if (!items.some(p => p.active)) {
                gameState = 'WIN';
                const ov = document.getElementById('message-overlay');
                ov.classList.remove('hidden');
                ov.querySelector('h1').innerText = "YOU WIN!";
                ov.querySelector('p').innerHTML = `Score: ${score}<br>Analyzing performance...`;

                triggerGameReview(true, score);
            }
        }

        init();

    </script>
</body>

</html>
